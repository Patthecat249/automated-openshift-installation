# Execute on install-vm

- name: "Install {{ bstrp.name }}-VM"
  become: "true"
  become_user: "root"
  hosts: 127.0.0.1
  gather_facts: "false"
  vars_files:
    - "../vars/vars.yaml"
  vars:
    - cpu: "{{ bstrp.cpu }}"
    - ram: "{{ bstrp.ram }}"
    - hostname: "{{ bstrp.hostname }}"
    - ip: "{{ bstrp.ip }}"
    - ignition_file: "{{ignition_filename_bootstrap}}"
 
  tasks:
# Erstelle Arbeitsverzeichnisse
    - name: "01 --- Create Working-Directories"
      file:
        path: "{{ item }}"
        state: "directory"
        recurse: "true"
      with_items:
        - "{{ dir_root }}"
        - "{{ dir_terraform }}{{ bstrp.hostname }}"
        - "{{ dir_terraform_module_vm }}"
      tags:
        - create

# Prüfe, ob der Hostname {{bstrp.hostname}} bereits in /etc/dnsmasq.conf existiert.
    - name: "02 --- Check, if IP-Address {{ bstrp.hostname }} exists in /etc/dnsmasq.conf"
      command: "grep \"{{ bstrp.hostname }}\" /etc/dnsmasq.conf"
      register: is_hostname_in_dnsmasq
      check_mode: no
      ignore_errors: yes
      changed_when: no
      delegate_to: "{{ bastion.ip }}"
      tags:
        - checker

    - name: "03 --- If /etc/dnsmasq.conf contains {{ bstrp.hostname }}, Stop Ansible-Playbook"
      debug: msg="Der Hostname {{ bstrp.hostname }} existiert bereits in /etc/dnsmasq.conf!"
      when: is_hostname_in_dnsmasq.rc == 0
      tags:
        - checker

# Beende das Playbook, wenn die IP-Adresse bereits in /etc/dnsmasq.conf existiert
    # - meta: end_play
    #   when: checkmyconf.rc == 0
# Beende das Playbook, wenn der Hostname bereits in /etc/dnsmasq.conf existiert
    - meta: end_play
      when: is_hostname_in_dnsmasq.rc == 0

# Erstelle VM-Instanz Terraform "main.tf"-file
# In dieser Datei wird auf auf das Terraform-Modul verwiesen
    - name: "04 --- Create main.tf-file from ocp-master-tf.j2"
      template:
        src: "../99-jinja-templates/terraform/ocp-master-tf.j2"
        dest: "{{ dir_terraform }}{{ bstrp.hostname }}/main.tf"
      tags:
        - create

# Erzeuge und kopiere das output.tf-file in den VM-Instanz-Ordner
    - name: "05 --- Create output.tf-file from jinja-template output.tf"
      template:
        src: "../99-jinja-templates/terraform/output.j2"
        dest: "{{ dir_terraform }}{{ bstrp.hostname }}/output.tf"
      tags:
        - create

# Erstelle und kopiere das vars.tf-file in den Terraform-Module Ordner
    - name: "06 --- Create vars.tf-file from jinja-template vars-coreos-tf.j2"
      template:
        src: "../99-jinja-templates/terraform/vars-coreos-tf.j2"
        dest: "{{ dir_terraform }}{{ bstrp.hostname }}/vars.tf"
      tags:
        - create

# Erstelle und kopiere das main.tf-file in den Terraform-Module Ordner
# Clone-Modul: Die VM wird aus einem Clone erzeugt.
    - name: "07 --- Create main.tf-file from jinja-template main.tf"
      template:
        src: "../../terraform/templates/clone.tf.j2"
        dest: "{{ dir_terraform_module_vm }}main.tf"
      tags:
        - create

# Erzeuge und kopiere das output.tf-file in den Terraform-Module Ordner 
    - name: "08 --- Create output.tf-file from jinja-template output.tf"
      template:
        src: "../../terraform/modules/vm-vsphere/output.tf"
        dest: "{{ dir_terraform_module_vm }}output.tf"
      tags:
        - create

# Erzeuge die virtuelle Maschine
    - name: "09 --- Create virtual machine with terraform"
      raw: "cd {{ dir_terraform }}{{ bstrp.hostname }} && /usr/local/bin/terraform init && /usr/local/bin/terraform apply -auto-approve"

# Ermittle die MAC-Adresse, der erzeugten VM
    - name: "10 --- Retrieve mac-address from created virtual machine"
      raw: "cd {{ dir_terraform }}{{ bstrp.hostname }} && /usr/local/bin/terraform output -json | jq '.[\"mac-address\"].value' | sed -e 's|\"||g'"
      register: mac

# Erstelle für diese VM, anhand der MAC-Adresse ein PXELINUX-Config-File im TFTPROOT-Dir vom PXE-SERVER
    - name: "11 --- Create pxelinux-config-file with mac-address-filename on tftproot on pxe-server"
      become: "true"
      become_user: "root"
      template:
        src: "../99-jinja-templates/pxe/pxelinux.cfg.j2"
        dest: "{{dir_tftproot}}01-{{ mac.stdout | trim | regex_replace(':', '-')}}"
        mode: "0755"
        owner: "dnsmasq"
        group: "wheel"
      delegate_to: "{{ bastion.ip }}"

# Erzeuge anhand der Mac-Adresse, IP-Adresse und des Hostnames, einen DHCP-Eintrag in DNSMASQ
    - name: "12 --- Add DHCP-entry to dnsmasq.conf"
      become: "true"
      become_user: "root"
      lineinfile:
        path: /etc/dnsmasq.conf
        insertafter: "^# DHCP-Host-Entries"         
        line: "dhcp-host={{ mac.stdout | trim }},{{ bstrp.hostname }},{{ bstrp.ip }},set:openshift_node"
      delegate_to: "{{ bastion.ip }}"
      notify: "restart dnsmasq"

# Erzeuge anhand der Mac-Adresse, IP-Adresse und des Hostnames, einen DNS-Lookup-Eintrag in DNSMASQ
    - name: "13 --- Add DNS-Lookup-entry to dnsmasq.conf"
      become: "true"
      become_user: "root"
      lineinfile:
        path: "/etc/dnsmasq.conf"
        insertafter: "^# DNS-Name-Resolution" 
        line: "address=/{{ bstrp.hostname }}.{{clustername}}.{{domain}}/{{ bstrp.ip }}"
      delegate_to: "{{ bastion.ip }}"
      notify: "restart dnsmasq"

# Starte den DNS-Dienst erneut, wenn sich etwas an der DNS-Konfiguration geändert hat.
  handlers:
    - name: "restart dnsmasq"
      become: "true"
      become_user: "root"
      service:
        name: dnsmasq
        state: restarted
      delegate_to: "{{ bastion.ip }}"

### --------------------------------------------------------------------------------- ###

# Execute on install-vm

- name: "Install {{ masters[0].name }}-VM"
  become: "true"
  become_user: "root"
  hosts: 127.0.0.1
  gather_facts: "false"
  vars_files:
    - "../vars/vars.yaml"
  vars:
    - cpu: "{{ masters[0].cpu }}"
    - ram: "{{ masters[0].ram }}"
    - hostname: "{{ masters[0].hostname }}"
    - ip: "{{ masters[0].ip }}"
    - ignition_file: "{{ignition_filename_master}}"
 
  tasks:
# Erstelle Arbeitsverzeichnisse
    - name: "01 --- Create Working-Directories"
      file:
        path: "{{ item }}"
        state: "directory"
        recurse: "true"
      with_items:
        - "{{ dir_root }}"
        - "{{ dir_terraform }}{{ masters[0].hostname }}"
        - "{{ dir_terraform_module_vm }}"
      tags:
        - create

# Prüfe, ob der Hostname {{masters[0].hostname}} bereits in /etc/dnsmasq.conf existiert.
    - name: "02 --- Check, if IP-Address {{ masters[0].hostname }} exists in /etc/dnsmasq.conf"
      command: "grep \"{{ masters[0].hostname }}\" /etc/dnsmasq.conf"
      register: is_hostname_in_dnsmasq
      check_mode: no
      ignore_errors: yes
      changed_when: no
      delegate_to: "{{ bastion.ip }}"
      tags:
        - checker

    - name: "03 --- If /etc/dnsmasq.conf contains {{ masters[0].hostname }}, Stop Ansible-Playbook"
      debug: msg="Der Hostname {{ masters[0].hostname }} existiert bereits in /etc/dnsmasq.conf!"
      when: is_hostname_in_dnsmasq.rc == 0
      tags:
        - checker

# Beende das Playbook, wenn die IP-Adresse bereits in /etc/dnsmasq.conf existiert
    # - meta: end_play
    #   when: checkmyconf.rc == 0
# Beende das Playbook, wenn der Hostname bereits in /etc/dnsmasq.conf existiert
    - meta: end_play
      when: is_hostname_in_dnsmasq.rc == 0

# Erstelle VM-Instanz Terraform "main.tf"-file
# In dieser Datei wird auf auf das Terraform-Modul verwiesen
    - name: "04 --- Create main.tf-file from ocp-master-tf.j2"
      template:
        src: "../99-jinja-templates/terraform/ocp-master-tf.j2"
        dest: "{{ dir_terraform }}{{ masters[0].hostname }}/main.tf"
      tags:
        - create

# Erzeuge und kopiere das output.tf-file in den VM-Instanz-Ordner
    - name: "05 --- Create output.tf-file from jinja-template output.tf"
      template:
        src: "../99-jinja-templates/terraform/output.j2"
        dest: "{{ dir_terraform }}{{ masters[0].hostname }}/output.tf"
      tags:
        - create

# Erstelle und kopiere das vars.tf-file in den Terraform-Module Ordner
    - name: "06 --- Create vars.tf-file from jinja-template vars-coreos-tf.j2"
      template:
        src: "../99-jinja-templates/terraform/vars-coreos-tf.j2"
        dest: "{{ dir_terraform }}{{ masters[0].hostname }}/vars.tf"
      tags:
        - create

# Erstelle und kopiere das main.tf-file in den Terraform-Module Ordner
# Clone-Modul: Die VM wird aus einem Clone erzeugt.
    - name: "07 --- Create main.tf-file from jinja-template main.tf"
      template:
        src: "../../terraform/templates/clone.tf.j2"
        dest: "{{ dir_terraform_module_vm }}main.tf"
      tags:
        - create

# Erzeuge und kopiere das output.tf-file in den Terraform-Module Ordner 
    - name: "08 --- Create output.tf-file from jinja-template output.tf"
      template:
        src: "../../terraform/modules/vm-vsphere/output.tf"
        dest: "{{ dir_terraform_module_vm }}output.tf"
      tags:
        - create

# Erzeuge die virtuelle Maschine
    - name: "09 --- Create virtual machine with terraform"
      raw: "cd {{ dir_terraform }}{{ masters[0].hostname }} && /usr/local/bin/terraform init && /usr/local/bin/terraform apply -auto-approve"

# Ermittle die MAC-Adresse, der erzeugten VM
    - name: "10 --- Retrieve mac-address from created virtual machine"
      raw: "cd {{ dir_terraform }}{{ masters[0].hostname }} && /usr/local/bin/terraform output -json | jq '.[\"mac-address\"].value' | sed -e 's|\"||g'"
      register: mac

# Erstelle für diese VM, anhand der MAC-Adresse ein PXELINUX-Config-File im TFTPROOT-Dir vom PXE-SERVER
    - name: "11 --- Create pxelinux-config-file with mac-address-filename on tftproot on pxe-server"
      become: "true"
      become_user: "root"
      template:
        src: "../99-jinja-templates/pxe/pxelinux.cfg.j2"
        dest: "{{dir_tftproot}}01-{{ mac.stdout | trim | regex_replace(':', '-')}}"
        mode: "0755"
        owner: "dnsmasq"
        group: "wheel"
      delegate_to: "{{ bastion.ip }}"

# Erzeuge anhand der Mac-Adresse, IP-Adresse und des Hostnames, einen DHCP-Eintrag in DNSMASQ
    - name: "12 --- Add DHCP-entry to dnsmasq.conf"
      become: "true"
      become_user: "root"
      lineinfile:
        path: /etc/dnsmasq.conf
        insertafter: "^# DHCP-Host-Entries"         
        line: "dhcp-host={{ mac.stdout | trim }},{{ masters[0].hostname }},{{ masters[0].ip }},set:openshift_node"
      delegate_to: "{{ bastion.ip }}"
      notify: "restart dnsmasq"

# Erzeuge anhand der Mac-Adresse, IP-Adresse und des Hostnames, einen DNS-Lookup-Eintrag in DNSMASQ
    - name: "13 --- Add DNS-Lookup-entry to dnsmasq.conf"
      become: "true"
      become_user: "root"
      lineinfile:
        path: "/etc/dnsmasq.conf"
        insertafter: "^# DNS-Name-Resolution" 
        line: "address=/{{ masters[0].hostname }}.{{clustername}}.{{domain}}/{{ masters[0].ip }}"
      delegate_to: "{{ bastion.ip }}"
      notify: "restart dnsmasq"

# Starte den DNS-Dienst erneut, wenn sich etwas an der DNS-Konfiguration geändert hat.
  handlers:
    - name: "restart dnsmasq"
      become: "true"
      become_user: "root"
      service:
        name: dnsmasq
        state: restarted
      delegate_to: "{{ bastion.ip }}"

### ----------------------------------------------------------------------------------------------- ###

# Execute on install-vm

- name: "Install {{ masters[1].name }}-VM"
  become: "true"
  become_user: "root"
  hosts: 127.0.0.1
  gather_facts: "false"
  vars_files:
    - "../vars/vars.yaml"
  vars:
    - cpu: "{{ masters[1].cpu }}"
    - ram: "{{ masters[1].ram }}"
    - hostname: "{{ masters[1].hostname }}"
    - ip: "{{ masters[1].ip }}"
    - ignition_file: "{{ignition_filename_master}}"
 
  tasks:
# Erstelle Arbeitsverzeichnisse
    - name: "01 --- Create Working-Directories"
      file:
        path: "{{ item }}"
        state: "directory"
        recurse: "true"
      with_items:
        - "{{ dir_root }}"
        - "{{ dir_terraform }}{{ masters[1].hostname }}"
        - "{{ dir_terraform_module_vm }}"
      tags:
        - create

# Prüfe, ob der Hostname {{masters[1].hostname}} bereits in /etc/dnsmasq.conf existiert.
    - name: "02 --- Check, if IP-Address {{ masters[1].hostname }} exists in /etc/dnsmasq.conf"
      command: "grep \"{{ masters[1].hostname }}\" /etc/dnsmasq.conf"
      register: is_hostname_in_dnsmasq
      check_mode: no
      ignore_errors: yes
      changed_when: no
      delegate_to: "{{ bastion.ip }}"
      tags:
        - checker

    - name: "03 --- If /etc/dnsmasq.conf contains {{ masters[1].hostname }}, Stop Ansible-Playbook"
      debug: msg="Der Hostname {{ masters[1].hostname }} existiert bereits in /etc/dnsmasq.conf!"
      when: is_hostname_in_dnsmasq.rc == 0
      tags:
        - checker

# Beende das Playbook, wenn die IP-Adresse bereits in /etc/dnsmasq.conf existiert
    # - meta: end_play
    #   when: checkmyconf.rc == 0
# Beende das Playbook, wenn der Hostname bereits in /etc/dnsmasq.conf existiert
    - meta: end_play
      when: is_hostname_in_dnsmasq.rc == 0

# Erstelle VM-Instanz Terraform "main.tf"-file
# In dieser Datei wird auf auf das Terraform-Modul verwiesen
    - name: "04 --- Create main.tf-file from ocp-master-tf.j2"
      template:
        src: "../99-jinja-templates/terraform/ocp-master-tf.j2"
        dest: "{{ dir_terraform }}{{ masters[1].hostname }}/main.tf"
      tags:
        - create

# Erzeuge und kopiere das output.tf-file in den VM-Instanz-Ordner
    - name: "05 --- Create output.tf-file from jinja-template output.tf"
      template:
        src: "../99-jinja-templates/terraform/output.j2"
        dest: "{{ dir_terraform }}{{ masters[1].hostname }}/output.tf"
      tags:
        - create

# Erstelle und kopiere das vars.tf-file in den Terraform-Module Ordner
    - name: "06 --- Create vars.tf-file from jinja-template vars-coreos-tf.j2"
      template:
        src: "../99-jinja-templates/terraform/vars-coreos-tf.j2"
        dest: "{{ dir_terraform }}{{ masters[1].hostname }}/vars.tf"
      tags:
        - create

# Erstelle und kopiere das main.tf-file in den Terraform-Module Ordner
# Clone-Modul: Die VM wird aus einem Clone erzeugt.
    - name: "07 --- Create main.tf-file from jinja-template main.tf"
      template:
        src: "../../terraform/templates/clone.tf.j2"
        dest: "{{ dir_terraform_module_vm }}main.tf"
      tags:
        - create

# Erzeuge und kopiere das output.tf-file in den Terraform-Module Ordner 
    - name: "08 --- Create output.tf-file from jinja-template output.tf"
      template:
        src: "../../terraform/modules/vm-vsphere/output.tf"
        dest: "{{ dir_terraform_module_vm }}output.tf"
      tags:
        - create

# Erzeuge die virtuelle Maschine
    - name: "09 --- Create virtual machine with terraform"
      raw: "cd {{ dir_terraform }}{{ masters[1].hostname }} && /usr/local/bin/terraform init && /usr/local/bin/terraform apply -auto-approve"

# Ermittle die MAC-Adresse, der erzeugten VM
    - name: "10 --- Retrieve mac-address from created virtual machine"
      raw: "cd {{ dir_terraform }}{{ masters[1].hostname }} && /usr/local/bin/terraform output -json | jq '.[\"mac-address\"].value' | sed -e 's|\"||g'"
      register: mac

# Erstelle für diese VM, anhand der MAC-Adresse ein PXELINUX-Config-File im TFTPROOT-Dir vom PXE-SERVER
    - name: "11 --- Create pxelinux-config-file with mac-address-filename on tftproot on pxe-server"
      become: "true"
      become_user: "root"
      template:
        src: "../99-jinja-templates/pxe/pxelinux.cfg.j2"
        dest: "{{dir_tftproot}}01-{{ mac.stdout | trim | regex_replace(':', '-')}}"
        mode: "0755"
        owner: "dnsmasq"
        group: "wheel"
      delegate_to: "{{ bastion.ip }}"

# Erzeuge anhand der Mac-Adresse, IP-Adresse und des Hostnames, einen DHCP-Eintrag in DNSMASQ
    - name: "12 --- Add DHCP-entry to dnsmasq.conf"
      become: "true"
      become_user: "root"
      lineinfile:
        path: /etc/dnsmasq.conf
        insertafter: "^# DHCP-Host-Entries"         
        line: "dhcp-host={{ mac.stdout | trim }},{{ masters[1].hostname }},{{ masters[1].ip }},set:openshift_node"
      delegate_to: "{{ bastion.ip }}"
      notify: "restart dnsmasq"

# Erzeuge anhand der Mac-Adresse, IP-Adresse und des Hostnames, einen DNS-Lookup-Eintrag in DNSMASQ
    - name: "13 --- Add DNS-Lookup-entry to dnsmasq.conf"
      become: "true"
      become_user: "root"
      lineinfile:
        path: "/etc/dnsmasq.conf"
        insertafter: "^# DNS-Name-Resolution" 
        line: "address=/{{ masters[1].hostname }}.{{clustername}}.{{domain}}/{{ masters[1].ip }}"
      delegate_to: "{{ bastion.ip }}"
      notify: "restart dnsmasq"

# Starte den DNS-Dienst erneut, wenn sich etwas an der DNS-Konfiguration geändert hat.
  handlers:
    - name: "restart dnsmasq"
      become: "true"
      become_user: "root"
      service:
        name: dnsmasq
        state: restarted
      delegate_to: "{{ bastion.ip }}"

### ----------------------------------------------------------------------------------------------- ###

# Execute on install-vm

- name: "Install {{ masters[2].name }}-VM"
  become: "true"
  become_user: "root"
  hosts: 127.0.0.1
  gather_facts: "false"
  vars_files:
    - "../vars/vars.yaml"
  vars:
    - cpu: "{{ masters[2].cpu }}"
    - ram: "{{ masters[2].ram }}"
    - hostname: "{{ masters[2].hostname }}"
    - ip: "{{ masters[2].ip }}"
    - ignition_file: "{{ignition_filename_master}}"
 
  tasks:
# Erstelle Arbeitsverzeichnisse
    - name: "01 --- Create Working-Directories"
      file:
        path: "{{ item }}"
        state: "directory"
        recurse: "true"
      with_items:
        - "{{ dir_root }}"
        - "{{ dir_terraform }}{{ masters[2].hostname }}"
        - "{{ dir_terraform_module_vm }}"
      tags:
        - create

# Prüfe, ob der Hostname {{masters[2].hostname}} bereits in /etc/dnsmasq.conf existiert.
    - name: "02 --- Check, if IP-Address {{ masters[2].hostname }} exists in /etc/dnsmasq.conf"
      command: "grep \"{{ masters[2].hostname }}\" /etc/dnsmasq.conf"
      register: is_hostname_in_dnsmasq
      check_mode: no
      ignore_errors: yes
      changed_when: no
      delegate_to: "{{ bastion.ip }}"
      tags:
        - checker

    - name: "03 --- If /etc/dnsmasq.conf contains {{ masters[2].hostname }}, Stop Ansible-Playbook"
      debug: msg="Der Hostname {{ masters[2].hostname }} existiert bereits in /etc/dnsmasq.conf!"
      when: is_hostname_in_dnsmasq.rc == 0
      tags:
        - checker

# Beende das Playbook, wenn die IP-Adresse bereits in /etc/dnsmasq.conf existiert
    # - meta: end_play
    #   when: checkmyconf.rc == 0
# Beende das Playbook, wenn der Hostname bereits in /etc/dnsmasq.conf existiert
    - meta: end_play
      when: is_hostname_in_dnsmasq.rc == 0

# Erstelle VM-Instanz Terraform "main.tf"-file
# In dieser Datei wird auf auf das Terraform-Modul verwiesen
    - name: "04 --- Create main.tf-file from ocp-master-tf.j2"
      template:
        src: "../99-jinja-templates/terraform/ocp-master-tf.j2"
        dest: "{{ dir_terraform }}{{ masters[2].hostname }}/main.tf"
      tags:
        - create

# Erzeuge und kopiere das output.tf-file in den VM-Instanz-Ordner
    - name: "05 --- Create output.tf-file from jinja-template output.tf"
      template:
        src: "../99-jinja-templates/terraform/output.j2"
        dest: "{{ dir_terraform }}{{ masters[2].hostname }}/output.tf"
      tags:
        - create

# Erstelle und kopiere das vars.tf-file in den Terraform-Module Ordner
    - name: "06 --- Create vars.tf-file from jinja-template vars-coreos-tf.j2"
      template:
        src: "../99-jinja-templates/terraform/vars-coreos-tf.j2"
        dest: "{{ dir_terraform }}{{ masters[2].hostname }}/vars.tf"
      tags:
        - create

# Erstelle und kopiere das main.tf-file in den Terraform-Module Ordner
# Clone-Modul: Die VM wird aus einem Clone erzeugt.
    - name: "07 --- Create main.tf-file from jinja-template main.tf"
      template:
        src: "../../terraform/templates/clone.tf.j2"
        dest: "{{ dir_terraform_module_vm }}main.tf"
      tags:
        - create

# Erzeuge und kopiere das output.tf-file in den Terraform-Module Ordner 
    - name: "08 --- Create output.tf-file from jinja-template output.tf"
      template:
        src: "../../terraform/modules/vm-vsphere/output.tf"
        dest: "{{ dir_terraform_module_vm }}output.tf"
      tags:
        - create

# Erzeuge die virtuelle Maschine
    - name: "09 --- Create virtual machine with terraform"
      raw: "cd {{ dir_terraform }}{{ masters[2].hostname }} && /usr/local/bin/terraform init && /usr/local/bin/terraform apply -auto-approve"

# Ermittle die MAC-Adresse, der erzeugten VM
    - name: "10 --- Retrieve mac-address from created virtual machine"
      raw: "cd {{ dir_terraform }}{{ masters[2].hostname }} && /usr/local/bin/terraform output -json | jq '.[\"mac-address\"].value' | sed -e 's|\"||g'"
      register: mac

# Erstelle für diese VM, anhand der MAC-Adresse ein PXELINUX-Config-File im TFTPROOT-Dir vom PXE-SERVER
    - name: "11 --- Create pxelinux-config-file with mac-address-filename on tftproot on pxe-server"
      become: "true"
      become_user: "root"
      template:
        src: "../99-jinja-templates/pxe/pxelinux.cfg.j2"
        dest: "{{dir_tftproot}}01-{{ mac.stdout | trim | regex_replace(':', '-')}}"
        mode: "0755"
        owner: "dnsmasq"
        group: "wheel"
      delegate_to: "{{ bastion.ip }}"

# Erzeuge anhand der Mac-Adresse, IP-Adresse und des Hostnames, einen DHCP-Eintrag in DNSMASQ
    - name: "12 --- Add DHCP-entry to dnsmasq.conf"
      become: "true"
      become_user: "root"
      lineinfile:
        path: /etc/dnsmasq.conf
        insertafter: "^# DHCP-Host-Entries"         
        line: "dhcp-host={{ mac.stdout | trim }},{{ masters[2].hostname }},{{ masters[2].ip }},set:openshift_node"
      delegate_to: "{{ bastion.ip }}"
      notify: "restart dnsmasq"

# Erzeuge anhand der Mac-Adresse, IP-Adresse und des Hostnames, einen DNS-Lookup-Eintrag in DNSMASQ
    - name: "13 --- Add DNS-Lookup-entry to dnsmasq.conf"
      become: "true"
      become_user: "root"
      lineinfile:
        path: "/etc/dnsmasq.conf"
        insertafter: "^# DNS-Name-Resolution" 
        line: "address=/{{ masters[2].hostname }}.{{clustername}}.{{domain}}/{{ masters[2].ip }}"
      delegate_to: "{{ bastion.ip }}"
      notify: "restart dnsmasq"

# Starte den DNS-Dienst erneut, wenn sich etwas an der DNS-Konfiguration geändert hat.
  handlers:
    - name: "restart dnsmasq"
      become: "true"
      become_user: "root"
      service:
        name: dnsmasq
        state: restarted
      delegate_to: "{{ bastion.ip }}"

### ----------------------------------------------------------------------------------------------- ###

# Execute on install-vm

- name: "Install {{ workers[0].name }}-VM"
  become: "true"
  become_user: "root"
  hosts: 127.0.0.1
  gather_facts: "false"
  vars_files:
    - "../vars/vars.yaml"
  vars:
    - cpu: "{{ workers[0].cpu }}"
    - ram: "{{ workers[0].ram }}"
    - hostname: "{{ workers[0].hostname }}"
    - ip: "{{ workers[0].ip }}"
    - ignition_file: "{{ignition_filename_worker}}"
 
  tasks:
# Erstelle Arbeitsverzeichnisse
    - name: "01 --- Create Working-Directories"
      file:
        path: "{{ item }}"
        state: "directory"
        recurse: "true"
      with_items:
        - "{{ dir_root }}"
        - "{{ dir_terraform }}{{ workers[0].hostname }}"
        - "{{ dir_terraform_module_vm }}"
      tags:
        - create

# Prüfe, ob der Hostname {{workers[0].hostname}} bereits in /etc/dnsmasq.conf existiert.
    - name: "02 --- Check, if IP-Address {{ workers[0].hostname }} exists in /etc/dnsmasq.conf"
      command: "grep \"{{ workers[0].hostname }}\" /etc/dnsmasq.conf"
      register: is_hostname_in_dnsmasq
      check_mode: no
      ignore_errors: yes
      changed_when: no
      delegate_to: "{{ bastion.ip }}"
      tags:
        - checker

    - name: "03 --- If /etc/dnsmasq.conf contains {{ workers[0].hostname }}, Stop Ansible-Playbook"
      debug: msg="Der Hostname {{ workers[0].hostname }} existiert bereits in /etc/dnsmasq.conf!"
      when: is_hostname_in_dnsmasq.rc == 0
      tags:
        - checker

# Beende das Playbook, wenn die IP-Adresse bereits in /etc/dnsmasq.conf existiert
    # - meta: end_play
    #   when: checkmyconf.rc == 0
# Beende das Playbook, wenn der Hostname bereits in /etc/dnsmasq.conf existiert
    - meta: end_play
      when: is_hostname_in_dnsmasq.rc == 0

# Erstelle VM-Instanz Terraform "main.tf"-file
# In dieser Datei wird auf auf das Terraform-Modul verwiesen
    - name: "04 --- Create main.tf-file from ocp-master-tf.j2"
      template:
        src: "../99-jinja-templates/terraform/ocp-master-tf.j2"
        dest: "{{ dir_terraform }}{{ workers[0].hostname }}/main.tf"
      tags:
        - create

# Erzeuge und kopiere das output.tf-file in den VM-Instanz-Ordner
    - name: "05 --- Create output.tf-file from jinja-template output.tf"
      template:
        src: "../99-jinja-templates/terraform/output.j2"
        dest: "{{ dir_terraform }}{{ workers[0].hostname }}/output.tf"
      tags:
        - create

# Erstelle und kopiere das vars.tf-file in den Terraform-Module Ordner
    - name: "06 --- Create vars.tf-file from jinja-template vars-coreos-tf.j2"
      template:
        src: "../99-jinja-templates/terraform/vars-coreos-tf.j2"
        dest: "{{ dir_terraform }}{{ workers[0].hostname }}/vars.tf"
      tags:
        - create

# Erstelle und kopiere das main.tf-file in den Terraform-Module Ordner
# Clone-Modul: Die VM wird aus einem Clone erzeugt.
    - name: "07 --- Create main.tf-file from jinja-template main.tf"
      template:
        src: "../../terraform/templates/clone.tf.j2"
        dest: "{{ dir_terraform_module_vm }}main.tf"
      tags:
        - create

# Erzeuge und kopiere das output.tf-file in den Terraform-Module Ordner 
    - name: "08 --- Create output.tf-file from jinja-template output.tf"
      template:
        src: "../../terraform/modules/vm-vsphere/output.tf"
        dest: "{{ dir_terraform_module_vm }}output.tf"
      tags:
        - create

# Erzeuge die virtuelle Maschine
    - name: "09 --- Create virtual machine with terraform"
      raw: "cd {{ dir_terraform }}{{ workers[0].hostname }} && /usr/local/bin/terraform init && /usr/local/bin/terraform apply -auto-approve"

# Ermittle die MAC-Adresse, der erzeugten VM
    - name: "10 --- Retrieve mac-address from created virtual machine"
      raw: "cd {{ dir_terraform }}{{ workers[0].hostname }} && /usr/local/bin/terraform output -json | jq '.[\"mac-address\"].value' | sed -e 's|\"||g'"
      register: mac

# Erstelle für diese VM, anhand der MAC-Adresse ein PXELINUX-Config-File im TFTPROOT-Dir vom PXE-SERVER
    - name: "11 --- Create pxelinux-config-file with mac-address-filename on tftproot on pxe-server"
      become: "true"
      become_user: "root"
      template:
        src: "../99-jinja-templates/pxe/pxelinux.cfg.j2"
        dest: "{{dir_tftproot}}01-{{ mac.stdout | trim | regex_replace(':', '-')}}"
        mode: "0755"
        owner: "dnsmasq"
        group: "wheel"
      delegate_to: "{{ bastion.ip }}"

# Erzeuge anhand der Mac-Adresse, IP-Adresse und des Hostnames, einen DHCP-Eintrag in DNSMASQ
    - name: "12 --- Add DHCP-entry to dnsmasq.conf"
      become: "true"
      become_user: "root"
      lineinfile:
        path: /etc/dnsmasq.conf
        insertafter: "^# DHCP-Host-Entries"         
        line: "dhcp-host={{ mac.stdout | trim }},{{ workers[0].hostname }},{{ workers[0].ip }},set:openshift_node"
      delegate_to: "{{ bastion.ip }}"
      notify: "restart dnsmasq"

# Erzeuge anhand der Mac-Adresse, IP-Adresse und des Hostnames, einen DNS-Lookup-Eintrag in DNSMASQ
    - name: "13 --- Add DNS-Lookup-entry to dnsmasq.conf"
      become: "true"
      become_user: "root"
      lineinfile:
        path: "/etc/dnsmasq.conf"
        insertafter: "^# DNS-Name-Resolution" 
        line: "address=/{{ workers[0].hostname }}.{{clustername}}.{{domain}}/{{ workers[0].ip }}"
      delegate_to: "{{ bastion.ip }}"
      notify: "restart dnsmasq"

# Starte den DNS-Dienst erneut, wenn sich etwas an der DNS-Konfiguration geändert hat.
  handlers:
    - name: "restart dnsmasq"
      become: "true"
      become_user: "root"
      service:
        name: dnsmasq
        state: restarted
      delegate_to: "{{ bastion.ip }}"

### ----------------------------------------------------------------------------------------------- ###

# Execute on install-vm

- name: "Install {{ workers[1].name }}-VM"
  become: "true"
  become_user: "root"
  hosts: 127.0.0.1
  gather_facts: "false"
  vars_files:
    - "../vars/vars.yaml"
  vars:
    - cpu: "{{ workers[1].cpu }}"
    - ram: "{{ workers[1].ram }}"
    - hostname: "{{ workers[1].hostname }}"
    - ip: "{{ workers[1].ip }}"
    - ignition_file: "{{ignition_filename_worker}}"
 
  tasks:
# Erstelle Arbeitsverzeichnisse
    - name: "01 --- Create Working-Directories"
      file:
        path: "{{ item }}"
        state: "directory"
        recurse: "true"
      with_items:
        - "{{ dir_root }}"
        - "{{ dir_terraform }}{{ workers[1].hostname }}"
        - "{{ dir_terraform_module_vm }}"
      tags:
        - create

# Prüfe, ob der Hostname {{workers[1].hostname}} bereits in /etc/dnsmasq.conf existiert.
    - name: "02 --- Check, if IP-Address {{ workers[1].hostname }} exists in /etc/dnsmasq.conf"
      command: "grep \"{{ workers[1].hostname }}\" /etc/dnsmasq.conf"
      register: is_hostname_in_dnsmasq
      check_mode: no
      ignore_errors: yes
      changed_when: no
      delegate_to: "{{ bastion.ip }}"
      tags:
        - checker

    - name: "03 --- If /etc/dnsmasq.conf contains {{ workers[1].hostname }}, Stop Ansible-Playbook"
      debug: msg="Der Hostname {{ workers[1].hostname }} existiert bereits in /etc/dnsmasq.conf!"
      when: is_hostname_in_dnsmasq.rc == 0
      tags:
        - checker

# Beende das Playbook, wenn die IP-Adresse bereits in /etc/dnsmasq.conf existiert
    # - meta: end_play
    #   when: checkmyconf.rc == 0
# Beende das Playbook, wenn der Hostname bereits in /etc/dnsmasq.conf existiert
    - meta: end_play
      when: is_hostname_in_dnsmasq.rc == 0

# Erstelle VM-Instanz Terraform "main.tf"-file
# In dieser Datei wird auf auf das Terraform-Modul verwiesen
    - name: "04 --- Create main.tf-file from ocp-master-tf.j2"
      template:
        src: "../99-jinja-templates/terraform/ocp-master-tf.j2"
        dest: "{{ dir_terraform }}{{ workers[1].hostname }}/main.tf"
      tags:
        - create

# Erzeuge und kopiere das output.tf-file in den VM-Instanz-Ordner
    - name: "05 --- Create output.tf-file from jinja-template output.tf"
      template:
        src: "../99-jinja-templates/terraform/output.j2"
        dest: "{{ dir_terraform }}{{ workers[1].hostname }}/output.tf"
      tags:
        - create

# Erstelle und kopiere das vars.tf-file in den Terraform-Module Ordner
    - name: "06 --- Create vars.tf-file from jinja-template vars-coreos-tf.j2"
      template:
        src: "../99-jinja-templates/terraform/vars-coreos-tf.j2"
        dest: "{{ dir_terraform }}{{ workers[1].hostname }}/vars.tf"
      tags:
        - create

# Erstelle und kopiere das main.tf-file in den Terraform-Module Ordner
# Clone-Modul: Die VM wird aus einem Clone erzeugt.
    - name: "07 --- Create main.tf-file from jinja-template main.tf"
      template:
        src: "../../terraform/templates/clone.tf.j2"
        dest: "{{ dir_terraform_module_vm }}main.tf"
      tags:
        - create

# Erzeuge und kopiere das output.tf-file in den Terraform-Module Ordner 
    - name: "08 --- Create output.tf-file from jinja-template output.tf"
      template:
        src: "../../terraform/modules/vm-vsphere/output.tf"
        dest: "{{ dir_terraform_module_vm }}output.tf"
      tags:
        - create

# Erzeuge die virtuelle Maschine
    - name: "09 --- Create virtual machine with terraform"
      raw: "cd {{ dir_terraform }}{{ workers[1].hostname }} && /usr/local/bin/terraform init && /usr/local/bin/terraform apply -auto-approve"

# Ermittle die MAC-Adresse, der erzeugten VM
    - name: "10 --- Retrieve mac-address from created virtual machine"
      raw: "cd {{ dir_terraform }}{{ workers[1].hostname }} && /usr/local/bin/terraform output -json | jq '.[\"mac-address\"].value' | sed -e 's|\"||g'"
      register: mac

# Erstelle für diese VM, anhand der MAC-Adresse ein PXELINUX-Config-File im TFTPROOT-Dir vom PXE-SERVER
    - name: "11 --- Create pxelinux-config-file with mac-address-filename on tftproot on pxe-server"
      become: "true"
      become_user: "root"
      template:
        src: "../99-jinja-templates/pxe/pxelinux.cfg.j2"
        dest: "{{dir_tftproot}}01-{{ mac.stdout | trim | regex_replace(':', '-')}}"
        mode: "0755"
        owner: "dnsmasq"
        group: "wheel"
      delegate_to: "{{ bastion.ip }}"

# Erzeuge anhand der Mac-Adresse, IP-Adresse und des Hostnames, einen DHCP-Eintrag in DNSMASQ
    - name: "12 --- Add DHCP-entry to dnsmasq.conf"
      become: "true"
      become_user: "root"
      lineinfile:
        path: /etc/dnsmasq.conf
        insertafter: "^# DHCP-Host-Entries"         
        line: "dhcp-host={{ mac.stdout | trim }},{{ workers[1].hostname }},{{ workers[1].ip }},set:openshift_node"
      delegate_to: "{{ bastion.ip }}"
      notify: "restart dnsmasq"

# Erzeuge anhand der Mac-Adresse, IP-Adresse und des Hostnames, einen DNS-Lookup-Eintrag in DNSMASQ
    - name: "13 --- Add DNS-Lookup-entry to dnsmasq.conf"
      become: "true"
      become_user: "root"
      lineinfile:
        path: "/etc/dnsmasq.conf"
        insertafter: "^# DNS-Name-Resolution" 
        line: "address=/{{ workers[1].hostname }}.{{clustername}}.{{domain}}/{{ workers[1].ip }}"
      delegate_to: "{{ bastion.ip }}"
      notify: "restart dnsmasq"

# Starte den DNS-Dienst erneut, wenn sich etwas an der DNS-Konfiguration geändert hat.
  handlers:
    - name: "restart dnsmasq"
      become: "true"
      become_user: "root"
      service:
        name: dnsmasq
        state: restarted
      delegate_to: "{{ bastion.ip }}"

### ----------------------------------------------------------------------------------------------- ###

# Execute on install-vm

- name: "Install {{ workers[2].name }}-VM"
  become: "true"
  become_user: "root"
  hosts: 127.0.0.1
  gather_facts: "false"
  vars_files:
    - "../vars/vars.yaml"
  vars:
    - cpu: "{{ workers[2].cpu }}"
    - ram: "{{ workers[2].ram }}"
    - hostname: "{{ workers[2].hostname }}"
    - ip: "{{ workers[2].ip }}"
    - ignition_file: "{{ignition_filename_worker}}"
 
  tasks:
# Erstelle Arbeitsverzeichnisse
    - name: "01 --- Create Working-Directories"
      file:
        path: "{{ item }}"
        state: "directory"
        recurse: "true"
      with_items:
        - "{{ dir_root }}"
        - "{{ dir_terraform }}{{ workers[2].hostname }}"
        - "{{ dir_terraform_module_vm }}"
      tags:
        - create

# Prüfe, ob der Hostname {{workers[2].hostname}} bereits in /etc/dnsmasq.conf existiert.
    - name: "02 --- Check, if IP-Address {{ workers[2].hostname }} exists in /etc/dnsmasq.conf"
      command: "grep \"{{ workers[2].hostname }}\" /etc/dnsmasq.conf"
      register: is_hostname_in_dnsmasq
      check_mode: no
      ignore_errors: yes
      changed_when: no
      delegate_to: "{{ bastion.ip }}"
      tags:
        - checker

    - name: "03 --- If /etc/dnsmasq.conf contains {{ workers[2].hostname }}, Stop Ansible-Playbook"
      debug: msg="Der Hostname {{ workers[2].hostname }} existiert bereits in /etc/dnsmasq.conf!"
      when: is_hostname_in_dnsmasq.rc == 0
      tags:
        - checker

# Beende das Playbook, wenn die IP-Adresse bereits in /etc/dnsmasq.conf existiert
    # - meta: end_play
    #   when: checkmyconf.rc == 0
# Beende das Playbook, wenn der Hostname bereits in /etc/dnsmasq.conf existiert
    - meta: end_play
      when: is_hostname_in_dnsmasq.rc == 0

# Erstelle VM-Instanz Terraform "main.tf"-file
# In dieser Datei wird auf auf das Terraform-Modul verwiesen
    - name: "04 --- Create main.tf-file from ocp-master-tf.j2"
      template:
        src: "../99-jinja-templates/terraform/ocp-master-tf.j2"
        dest: "{{ dir_terraform }}{{ workers[2].hostname }}/main.tf"
      tags:
        - create

# Erzeuge und kopiere das output.tf-file in den VM-Instanz-Ordner
    - name: "05 --- Create output.tf-file from jinja-template output.tf"
      template:
        src: "../99-jinja-templates/terraform/output.j2"
        dest: "{{ dir_terraform }}{{ workers[2].hostname }}/output.tf"
      tags:
        - create

# Erstelle und kopiere das vars.tf-file in den Terraform-Module Ordner
    - name: "06 --- Create vars.tf-file from jinja-template vars-coreos-tf.j2"
      template:
        src: "../99-jinja-templates/terraform/vars-coreos-tf.j2"
        dest: "{{ dir_terraform }}{{ workers[2].hostname }}/vars.tf"
      tags:
        - create

# Erstelle und kopiere das main.tf-file in den Terraform-Module Ordner
# Clone-Modul: Die VM wird aus einem Clone erzeugt.
    - name: "07 --- Create main.tf-file from jinja-template main.tf"
      template:
        src: "../../terraform/templates/clone.tf.j2"
        dest: "{{ dir_terraform_module_vm }}main.tf"
      tags:
        - create

# Erzeuge und kopiere das output.tf-file in den Terraform-Module Ordner 
    - name: "08 --- Create output.tf-file from jinja-template output.tf"
      template:
        src: "../../terraform/modules/vm-vsphere/output.tf"
        dest: "{{ dir_terraform_module_vm }}output.tf"
      tags:
        - create

# Erzeuge die virtuelle Maschine
    - name: "09 --- Create virtual machine with terraform"
      raw: "cd {{ dir_terraform }}{{ workers[2].hostname }} && /usr/local/bin/terraform init && /usr/local/bin/terraform apply -auto-approve"

# Ermittle die MAC-Adresse, der erzeugten VM
    - name: "10 --- Retrieve mac-address from created virtual machine"
      raw: "cd {{ dir_terraform }}{{ workers[2].hostname }} && /usr/local/bin/terraform output -json | jq '.[\"mac-address\"].value' | sed -e 's|\"||g'"
      register: mac

# Erstelle für diese VM, anhand der MAC-Adresse ein PXELINUX-Config-File im TFTPROOT-Dir vom PXE-SERVER
    - name: "11 --- Create pxelinux-config-file with mac-address-filename on tftproot on pxe-server"
      become: "true"
      become_user: "root"
      template:
        src: "../99-jinja-templates/pxe/pxelinux.cfg.j2"
        dest: "{{dir_tftproot}}01-{{ mac.stdout | trim | regex_replace(':', '-')}}"
        mode: "0755"
        owner: "dnsmasq"
        group: "wheel"
      delegate_to: "{{ bastion.ip }}"

# Erzeuge anhand der Mac-Adresse, IP-Adresse und des Hostnames, einen DHCP-Eintrag in DNSMASQ
    - name: "12 --- Add DHCP-entry to dnsmasq.conf"
      become: "true"
      become_user: "root"
      lineinfile:
        path: /etc/dnsmasq.conf
        insertafter: "^# DHCP-Host-Entries"         
        line: "dhcp-host={{ mac.stdout | trim }},{{ workers[2].hostname }},{{ workers[2].ip }},set:openshift_node"
      delegate_to: "{{ bastion.ip }}"
      notify: "restart dnsmasq"

# Erzeuge anhand der Mac-Adresse, IP-Adresse und des Hostnames, einen DNS-Lookup-Eintrag in DNSMASQ
    - name: "13 --- Add DNS-Lookup-entry to dnsmasq.conf"
      become: "true"
      become_user: "root"
      lineinfile:
        path: "/etc/dnsmasq.conf"
        insertafter: "^# DNS-Name-Resolution" 
        line: "address=/{{ workers[2].hostname }}.{{clustername}}.{{domain}}/{{ workers[2].ip }}"
      delegate_to: "{{ bastion.ip }}"
      notify: "restart dnsmasq"

# Starte den DNS-Dienst erneut, wenn sich etwas an der DNS-Konfiguration geändert hat.
  handlers:
    - name: "restart dnsmasq"
      become: "true"
      become_user: "root"
      service:
        name: dnsmasq
        state: restarted
      delegate_to: "{{ bastion.ip }}"

